import Reply from "../tools/reply.handler";

export const statuscode: { [key: number]: string } = {
    [Reply.codes.UNAUTHORIZED]: "Um token de autenticação não foi encontrado",
	[Reply.codes.FORBIDDEN]: "Esse usuário não tem permissão para acessar esse recurso. Tente trocar de usuário ou relogar em sua conta",
	[Reply.codes.NOTFOUND]: "Não foi possível encontrar o que você procura.",
	[Reply.codes.GONE]: "Aparentemente, esse recurso não está mais disponível para acesso",
	[Reply.codes.BADREQUEST]: "Há requisitos que não foram atendidos em sua solicitação",
	[Reply.codes.UNSUPPORTEDMEDIA]: "O formato do arquivo enviado não corresponde a nenhum formato suportado pelo sistema",
	[Reply.codes.SERVERERROR]: "Houve um erro ao processar sua requisição",
	[Reply.codes.NOTIMPLEMENTED]: "Esse recurso ainda não está disponível para o uso"
}

export const validations: { [key: string]: string } = {
	"string.alphanum": "{{#label}} deve conter apenas caracteres alfanuméricos",
	"string.base": "{{#label}} deve ser uma string",
	"string.base64": "{{#label}} deve corresponder a uma string em base64",
	"string.creditCard": "{{#label}} informado não corresponde a um cartão de crédito válido",
	"string.dataUri": "{{#label}} deve ser uma string dataUri",
	"string.domain": "{{#label}} deve conter um domínio válido",
	"string.email": "{{#label}} informado não corresponde a um email válido",
	"string.empty": "Não é permitido que {{#label}} seja vazio",
	"string.guid": "{{#label}} não corresponde a um GUID válido",
	"string.hex": "{{#label}} deve conter apenas caracteres hexadecimais",
	"string.hexAlign": "A representação hexadecimal decodificada de {{#label}} deve ser alinhada por bytes",
	"string.hostname": "{{#label}} precisa ser um endereço válido",
	"string.ip": "{{#label}} deve ser um endereço IP válido",
	"string.ipVersion": "{{#label}} deve ser um endereço IP válido da seguinte versão: {{#version}}",
	"string.isoDate": "A data informada em {{#label}} não corresponde a um formato válido",
	"string.isoDuration": "A duração informada em {{#label}} não corresponde a um formato válido",
	"string.length": "O valor presente em {{#label}} deve conter exatamente {{#limit}} caracteres",
	"string.lowercase": "Não é permitido usar letras maiúsculas em {{#label}}",
	"string.max": "{{#label}} deve ter {{#limit}} caracteres, no máximo",
	"string.min": "{{#label}} não pode ter menos que {{#limit}} caracteres",
	"string.normalize": "O valor de {{#label}} deve ser normalizado no formato unicode {{#form}}",
	"string.token": "Apenas caracteres alfanuméricos e underlines são permitidos em {{#label}}",
	"string.pattern.base": "O valor \"{[.]}\" presente em {{#label}} não atende aos requisitos da expressão: {{#regex}}",
	"string.pattern.name": "O valor \"{[.]}\" presente em {{#label}} não atende aos requisitos de {{#name}}",
	"string.pattern.invert.base": "O valor \"{[.]}\" presente em {{#label}} não é permitido segundo a expressão: {{#regex}}",
	"string.pattern.invert.name": "O valor \"{[.]}\" presente em {{#label}} não é permitido segundo a expressão {{#name}}",
	"string.trim": "{{#label}} não deve iniciar ou terminar com espaços em branco",
	"string.uri": "{{#label}} não corresponde a uma URI válida",
	"string.uriCustomScheme": "{{#label}} deve conter uma URI válida com esquema correspondente ao padrão {{#scheme}}",
	"string.uriRelativeOnly": "{{#label}} deve conter uma URI relativa",
	"string.uppercase": "Letras minúsculas não são permitidas em {{#label}}",
    
	"number.base": "Somente números são aceitos em {{#label}}",
	"number.greater": "O valor de {{#label}} deve ser maior que {{#limit}}",
	"number.infinity": "O valor de {{#label}} não pode ser infinito",
	"number.integer": "Somente números inteiros são aceitos em {{#label}}",
	"number.less": "O valor de {{#label}} deve ser menor que {{#limit}}",
	"number.max": "Somente valores menores ou iguais a {{#limit}} são aceitos em {{#label}}",
	"number.min": "Somente valores maiores ou iguais a {{#limit}} são aceitos em {{#label}}",
	"number.multiple": "{{#label}} deve ser multiplo de {{#multiple}}",
	"number.negative": "O valor de {{#label}} deve ser negativo",
	"number.port": "{{#label}} não representa uma porta válida",
	"number.positive": "Valores negativos não são aceitos em {{#label}}",
	"number.precision": "{{#label}} não aceita números com mais de {{#limit}} casas decimais",
	"number.unsafe": "Não é possível processar o valor de {{#label}}",

    "boolean.base": "O valor de {{#label}} precisa ser verdadeiro ou falso (booleano)",

	"binary.base": "Somente um buffer ou string são aceitos em {{#label}}",
	"binary.length": "O buffer em {{#label}} deve conter {{#limit}} bytes",
	"binary.max": "Há mais bytes que o permitido em {{#label}}. Limite: {{#limit}}",
	"binary.min": "O buffer em {{#label}} é menor que o esperado. Limite: {{#limit}}",

	"any.custom": "{{#label}} não pode ser validado. Motivo: {{#error.message}}",
	"any.default": "{{#label}} provocou uma exceção ao acessar o valor padrão",
	"any.failover": "{{#label}} threw an error when running failover method",
	"any.invalid": "{{#label}} contém um valor inválido",
	"any.only": "{{#label}} deve ser {if(#valids.length == 1, \"\", \"um dos seguintes valores: \")}{{#valids}}",
	"any.ref": "{{#label}} {{#arg}} referencia \"{{#ref}}\" a qual {{#reason}}",
	"any.required": "{{#label}} é obrigatório",
	"any.unknown": "{{#label}} não é permitido",

	"alternatives.all": "{{#label}} não é compatível com nenhum dos tipos permitidos",
	"alternatives.any": "{{#label}} não é compatível com nenhum tipo permitido",
	"alternatives.match": "{{#label}} não coincidiu com nenhum tipo permitido",
	"alternatives.one": "{{#label}} coincide com mais de um tipo permitido",
	"alternatives.types": "{{#label}} deve ser de um dos seguintes tipos: {{#types}}",

	"array.base": "{{#label}} aceita apenas uma lista de itens [array]",
	"array.excludes": "A lista em {{#label}} contém um valor não permitido",
	"array.hasKnown": "A lista contida em {{#label}} não possui ao menos um ítem obrigatório solicitado por \"{#patternLabel}\"",
	"array.hasUnknown": "Um item obrigatório não foi encontrado na lista em {{#label}}",
	"array.includes": "O {{#pos + 1}}° item na lista {{#label}} não corresponde a nenhum tipo permitido",
	"array.includesRequiredBoth": "A lista {{#label}} deve conter {{#knownMisses}} e mais {{#unknownMisses}} outro(s) valor(es) obrigatório(s)",
	"array.includesRequiredKnowns": "A lista {{#label}} não contém {{#knownMisses}}",
	"array.includesRequiredUnknowns": "A lista {{#label}} deve conter {{#unknownMisses}} valor(es) obrigatórios",
	"array.length": "É necessário ter {{#limit}} itens na lista em {{#label}}",
	"array.max": "Não é permitido ter mais que {{#limit}} itens na lista em {{#label}}",
	"array.min": "A lista em {{#label}} deve ter ao menos {{#limit}} itens",
	"array.orderedLength": "{{#label}} must contain at most {{#limit}} items",
	"array.sort": "A lista {{#label}} deve ser ordenada por {{#by}} em ordem \"{#order}\"",
	"array.sort.mismatching": "A lista em {{#label}} não pôde ser ordenada pois seus tipos variam internamente",
	"array.sort.unsupported": "A lista {{#label}} não pôde ser ordenada pois o tipo {#type} não é suportado",
	"array.sparse": "A lista {{#label}} não pode conter slots com valores indefinidos",
	"array.unique": "Não é permitido itens duplicados na lista {{#label}} ",

	"date.base": "O valor de {{#label}} deve ser uma data válida",
	"date.format": "A data informada em {{#label}} deve estar no formato {msg(\"date.format.\" + #format) || #format}",
	"date.greater": "A data informada em {{#label}} não pode ser anterior à \"{{#limit}}\"",
	"date.less": "A data informada em {{#label}} não pode ser posterior à \"{{#limit}}\"",
	"date.max": "A data informada em {{#label}} deve ser anterior ou igual à {{#limit}}",
	"date.min": "A data informada em {{#label}} deve ser posterior ou igual à {{#limit}}",
	"date.format.iso": "ISO 8601",
	"date.format.javascript": "JS: Timestamp ou número de milisegundos",
	"date.format.unix": "UNIX: Timestamp ou número de segundos",

	"function.arity": "A função passada à {{#label}} deve conter {{#n}} parâmetros",
	"function.class": "{{#label}} deve ser uma classe",
	"function.maxArity": "A função passada à {{#label}} deve ter {{#n}} ou menos parâmetros",
	"function.minArity": "A função passada à {{#label}} deve ter, no mínimo, {{#n}} parâmetros",

	"object.and": "As regras de {{#label}} obrigam que {{#missingWithLabels}} esteja(m) presente(s) se {{#presentWithLabels}} estiver",
	"object.assert": "O valor de {{#label}} é invalido pois {if(#subject.key, `\"` + #subject.key + `\" falhou ao ` + (#message || \"passar no teste declarado\"), #message || \"seu valor não corresponde ao declarado\")}",
	"object.base": "O valor de {{#label}} deve ser do tipo {{#type}}",
	"object.instance": "O valor de {{#label}} deve ser instância de \"{{#type}}\"",
	"object.length": "O objeto {{#label}} deve ter {{#limit}} propriedade{if(#limit == 1, \"\", \"s\")}",
	"object.max": "O objeto {{#label}} deve ter, no máximo, {{#limit}} propriedade{if(#limit == 1, \"\", \"s\")}",
	"object.min": "O objeto {{#label}} deve ter, no mínimo, {{#limit}} propriedade{if(#limit == 1, \"\", \"s\")}",
	"object.missing": "Um dos seguintes valores devem estar presentes em {{#label}}: {{#peersWithLabels}}",
	"object.nand": "\"{{#mainWithLabel}}\" não deve estar presente se {{#peersWithLabels}} estiverem definidos",
	"object.oxor": "Embora opcionais, {{#label}} não deve ser informado caso {{#peersWithLabels}} estejam presentes",
	"object.pattern.match": "{{#label}} não atende os requesitos estabelecidos",
	"object.refType": "{{#label}} deve ser uma referência do Joi",
	"object.regex": "{{#label}} deve ser uma RegExp",
	"object.rename.multiple": "A propriedade \"{{#from}}\" não pode ser renomeada pois outra propriedade já foi renomeada para \"{{#to}}\" anteriormente",
	"object.rename.override": "A propriedade \"{{#from}}\" não pode ser renomeada pois já existe outra propriedade de nome \"{{#to}}\"",
	"object.schema": "{{#label}} deve ser um schema do Joi do tipo {{#type}}",
	"object.unknown": "A propriedade {{#label}} não era esperada e não deve ser informada",
	"object.with": "\"{{#peerWithLabel}}\" deve(m) ser definido(s), uma vez que {{#mainWithLabel}} foi informado",
	"object.without": "\"{{#peerWithLabel}}\" não deve estar presente quando \"{{#mainWithLabel}}\" for informado",
	"object.xor": "{{#label}} entra em conflito com {{#peersWithLabels}}, pois apenas um deles precisa ser informado"
};